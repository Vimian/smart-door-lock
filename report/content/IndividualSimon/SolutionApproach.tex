\subsection{Solution Approach}
[ IOT ]
\newline
%Describe the solution approach on a high-level including advantages and drawbacks based on relevant literature.
\subsubsection{2 Factor Authentication}
\gls{2fa} can be implemented in several different ways, voice, fingerprint, face scan, app, or pairing during setup. In section \ref{sec:solution} we decided to go with our current product to keep it simple for the end user. The objective is to implement a solution which mitigates the risk of an attacker gaining access by guessing the password while not complicating the process of gaining entrance for the user. Voice, fingerprints, face scan or an app would all be complicating the process for the end user. Voice, fingerprint, face scan would require an extra component which would increase the complexity of the solution and would require higher power consumption. An app would remove the ease of use which we want for the user. It could be implemented for higher security scenarios. Then an extra pairing during setup is the optimal solution here, it will increase setup time but run time there would be nearly no difference except for a longer wait for verification. During setup of the device, when a user pairs their device to the esp32 the first time, they have to hold down a pairing button during the process. Once the process is completed it will indicate to the user by going into an unlock state.

\subsubsection{Stopping Bruteforce attacks}
\gls{ftb} is made to stop an intruder from performing too many authentication attempts\cite{f2b}. \gls{ftb} does this by banning IP-addresses in a connection log\cite{f2bHowTo}. If too many of the same IPs shows up, it will assume there has been an infiltration attempt. In our case, we neither have a log to pull from as we have very limited storage and as everyone has phones, it would quickly pile up. Another difference is that an attacker would not carry same Bluetooth address, but have several fake ones, which is what we scan for. The solution here is after a Bluetooth advertisement has finished, we would count the total number of Bluetooth addresses and if it exceeds a certain limit, we assume an attack has started and block any further attempt.

There are several types of Bluetooth addresses, but only two are important in this case, 'public address' and 'random address'. A 'public address' is a fixed address which is registered with IEEE, the first 24bits is company assigned. The 'random address' does not have to follow any format and can be what the developer wishes\cite{BluetoothBeacon}. What we could do is only allow for verified phone companies, so if the first 24bits does not match with a company, we would not allow it to connect. The problem then would be if a company has their own custom devices, and we would have to keep our solution updated whenever a new company comes to market. So while it would be beneficial to only allow 'public address' to connect, we have to for future proofing our solution, work with 'random address' which can open up for the attacks which \gls{ftb} has to mitigate.